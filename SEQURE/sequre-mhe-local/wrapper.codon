import time, sys

from numpy.create import zeros

from sequre import local, Sharetensor as Stensor

from damerau_lev import damerau_levenshtein
from gener_ukkonen import gen_ukkonen
from levensthein import levenshtein
from ukkonen_arg import edit_distance_threshold, INF_VAL


@local
def local_wrapper(mpc, seq_1, seq_2, threshold):
    #damerau-levenshtein
    d_public = zeros((len(seq_2) + 1, len(seq_1) + 1), dtype=int)
    d_stensor = Stensor.enc(mpc, d_public)

    s = time.time()
    dam_lev_public = damerau_levenshtein(mpc, seq_1, seq_2, d_public)  # Esecuzione offline/stile Python del metodo levenshtein
    e = time.time()
    dam_lev_public_time = e - s

    s = time.time()
    dam_lev_stensor = damerau_levenshtein(mpc, seq_1, seq_2, d_stensor)  # Esecuzione sicura del metodo levenshtein
    e = time.time()
    dam_lev_stensor_time = e - s

    if mpc.pid:  # I risultati in CP0 sono spesso zero, quindi non c'è bisogno di controllarli qui. Tuttavia, è necessario assicurarsi che CP0 sia incluso nei calcoli sopra (quindi se il ramo mpc.pid è impostato solo qui)
        print(f"Distanza di modifica (Damerau-Levenshtein pubblica): {dam_lev_public} done in {dam_lev_public_time}s")
        print(f"Distanza di modifica (Damerau-Levenshtein sicura): {dam_lev_stensor.reveal(mpc)} done in {dam_lev_stensor_time}s")
   
    #Generalized Ukkonen
    row_public = zeros(len(seq_2) + 1, dtype=int)
    row_stensor = Stensor.enc(mpc, row_public)

    s = time.time()
    gu_public = gen_ukkonen(mpc, seq_1, seq_2, row_public)  # Esecuzione offline/stile Python del metodo levenshtein
    e = time.time()
    gu_public_time = e - s

    s = time.time()
    gu_stensor = gen_ukkonen(mpc, seq_1, seq_2, row_stensor)  # Esecuzione sicura del metodo levenshtein
    e = time.time()
    gu_stensor_time = e - s

    if mpc.pid:  # I risultati in CP0 sono spesso zero, quindi non c'è bisogno di controllarli qui. Tuttavia, è necessario assicurarsi che CP0 sia incluso nei calcoli sopra (quindi se il ramo mpc.pid è impostato solo qui)
        print(f"Distanza di modifica (Generalized Ukkonen pubblica): {gu_public} done in {gu_public_time}s")
        print(f"Distanza di modifica (Generalized Ukkonen sicura): {gu_stensor.reveal(mpc)} done in {gu_stensor_time}s")

    #levenshtein
    d_public = zeros((len(seq_2) + 1, len(seq_1) + 1), dtype=int)
    d_stensor = Stensor.enc(mpc, d_public)

    s = time.time()
    lev_public = levenshtein(mpc, seq_1, seq_2, d_public)  # Esecuzione offline/stile Python del metodo levenshtein
    e = time.time()
    lev_public_time = e - s

    s = time.time()
    lev_stensor = levenshtein(mpc, seq_1, seq_2, d_stensor)  # Esecuzione sicura del metodo levenshtein
    e = time.time()
    lev_stensor_time = e - s

    if mpc.pid:  # I risultati in CP0 sono spesso zero, quindi non c'è bisogno di controllarli qui. Tuttavia, è necessario assicurarsi che CP0 sia incluso nei calcoli sopra (quindi se il ramo mpc.pid è impostato solo qui)
        print(f"Distanza di modifica (Levenshtein pubblica): {lev_public} done in {lev_public_time}s")
        print(f"Distanza di modifica (Levenshtein sicura): {lev_stensor.reveal(mpc)} done in {lev_stensor_time}s")
   
    # Ukkonen
    p_public = zeros(len(seq_2) + 1, dtype=int)
    p_stensor = Stensor.enc(mpc, p_public)
    d_public = zeros(len(seq_2) + 1, dtype=int) + INF_VAL
    d_stensor = Stensor.enc(mpc, d_public)

    s = time.time()
    uk_public = edit_distance_threshold(mpc, seq_1, seq_2, threshold, p_public, d_public)
    e = time.time()
    uk_public_time = e - s

    s = time.time()
    uk_stensor = edit_distance_threshold(mpc, seq_1, seq_2, threshold, p_stensor, d_stensor)
    e = time.time()
    uk_stensor_time = e - s

    if mpc.pid:
        print(f"Distanza di modifica (Ukkonen pubblica, soglia {threshold}): {uk_public} done in {uk_public_time}s")
        print(f"Distanza di modifica (Ukkonen sicura, soglia {threshold}): {uk_stensor.reveal(mpc)} done in {uk_stensor_time}s")


# Aggiunto il passaggio del parametro threshold (e il percorso del file di input) da input di linea di comando
args = [arg for arg in sys.argv[1:] if not arg.startswith("--")]
path = args[0]
threshold = int(args[-1]) if len(args) > 1 else 30

with open(path) as f:
    lines = f.readlines()
    # Tipi genetici nativi di Seq/Sequre
    from bio.seq import seq
    seq_1 = seq(lines[0].strip())
    seq_2 = seq(lines[1].strip())

local_wrapper(seq_1, seq_2, threshold)
