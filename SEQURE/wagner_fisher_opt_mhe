from numpy.create import arange

from sequre.attributes import sequre
from sequre.types.sharetensor import Sharetensor as Stensor


@sequre
def min(mpc, x, y):
    mask = ((y - x) > 0).astype(int)
    return x * mask - y * (mask - 1)


@sequre
def levenshtein_optimized_distance(mpc, s, t, modulus):
    m = len(s)
    n = len(t)
    row1 = Stensor.zeros(m + 1, modulus)
    row2 = Stensor.zeros(n + 1, modulus)

    for j in range(1, n + 1):
        row1[j] = row1[j] + j

    for i in range(1, m + 1):
        row2[0] = row2[0] + j
        for j in range(1, n + 1):
            cost = int(s[i - 1] != t[j - 1])
            row2[j] = min(
                mpc,
                min(mpc, row1[j] + 1, row2[j - 1] + 1),
                row1[j - 1] + cost)
            row1, row2 = (row2, row1)
    return row1[n]


@sequre  # Il decoratore Sequre abilita ottimizzazioni in fase di compilazione come la riduzione della profondità di moltiplicazione e la riorganizzazione delle espressioni per minimizzare il costo di rete
def wagner_fischer_O1(mpc, s, t, buf):  # Ogni funzione decorata con @sequre deve avere mpc come primo attributo. mpc è l'istanza della classe MPC che memorizza la configurazione di rete (numero di partecipanti, ecc.), flussi pseudo-casuali per migliorare le prestazioni e un insieme di operazioni aritmetiche essenziali per MPC
    # Supponendo che s e t siano pubblici e buf sia privato (condivisione segreta)
    n = len(s)  # Valore pubblico
    m = len(t)  # Valore pubblico

    for i in range(1, n + 1):  # Itera sull'intervallo pubblico
        tmp = buf[0]  # Sharetensor tmp memorizza il valore condiviso segreto di buf[0]
        # buf[0] = i  # Impostare un valore pubblico su Stensor privato non è possibile, utilizzare l'hack qui sotto:
        buf[0] = buf[0] * 0 + i  # Hack (finché il supporto per l'impostazione di valori pubblici non viene aggiunto). Questo calcolerà il valore di sharetensor (buf[0] * 0) e vi aggiungerà i pubblicamente

        for j in range(1, m + 1):  # Itera sull'intervallo pubblico
            if s[i - 1] == t[j - 1]:  # Controlla l'uguaglianza tra due valori pubblici
                tmp, buf[j] = buf[j], tmp  # Scambia
            else:
                val = min(mpc, buf[j], min(mpc, buf[j - 1], tmp)) + 1  # Calcola il minimo su sharetensor privati
                tmp, buf[j] = buf[j], val  # Scambia

    return buf[m]  # Restituisci il valore privato m-esimo in sharetensor buf


@sequre
def playground(mpc, a, b, c, d, e, f, g, h):
   
    # Tipi genomici nativi di Seq/Sequre
    seq_1 = s'gtcccacacggcaattgttaagctgcatatgcgaaggagaggacgtgcgc'
    seq_2 = s'aaatctcttccgtaagctgtcttgaggtacttggattggaagcagcccgg'
    
    lev = levenshtein_optimized_distance(mpc, seq_1, seq_2, a.modulus)
    
    buf_public = arange(len(seq_2) + 1, dtype=int)  # Buffer pubblico
    buf_stenor = Stensor.enc(mpc, buf_public, source_pid=0, modulus=a.modulus)  # Condivide segretamente il buffer a CP0 con altre parti
    wf_public = wagner_fischer_O1(mpc, seq_1, seq_2, buf_public)  # Esecuzione offline/stile Python del metodo wagner_fischer_O1
    wf_stensor = wagner_fischer_O1(mpc, seq_1, seq_2, buf_stenor)  # Esecuzione sicura del metodo wagner_fischer_O1

    if mpc.pid:  # I risultati a CP0 sono spesso zero, quindi non c'è bisogno di controllarli qui. Tuttavia, dobbiamo assicurarci che CP0 sia incluso nel calcolo sopra (quindi il ramo mpc.pid è impostato solo qui)
        print("Distanza di modifica (Levenshtein): ", lev.reveal(mpc))
        print("Distanza di modifica (Wagner-Fischer pubblico): ", wf_public)
        print("Distanza di modifica (Wagner-Fischer sicuro): ", wf_stensor.reveal(mpc))

    return a
